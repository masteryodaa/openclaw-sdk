# Agents & Execution

Agents are the primary way you interact with OpenClaw. An `Agent` object represents a handle to a specific AI agent running inside the OpenClaw framework. You obtain an agent from an `OpenClawClient` and then call methods on it to send queries, receive results, and manage state.

## Getting an Agent Handle

Use `client.get_agent()` to obtain an `Agent` instance. Every agent is identified by its `agent_id` and scoped to a **session**.

```python
import asyncio
from openclaw_sdk import OpenClawClient

async def main():
    async with OpenClawClient.connect("ws://127.0.0.1:18789/gateway") as client:
        # Default session name is "default"
        agent = client.get_agent("my-agent")

        # Explicit session name for conversation isolation
        support_agent = client.get_agent("my-agent", session_name="ticket-4821")

asyncio.run(main())
```

!!! note "Session Keys"
    Sessions are identified by a key with the format `agent:{agent_id}:{session_name}`. For example, `agent:my-agent:default`. The SDK builds this automatically â€” you just provide the agent ID and an optional session name.

## Basic Execution

The simplest way to use an agent is `execute()`, which sends a query and waits for the full response.

```python
import asyncio
from openclaw_sdk import OpenClawClient

async def main():
    async with OpenClawClient.connect("ws://127.0.0.1:18789/gateway") as client:
        agent = client.get_agent("my-agent")
        result = await agent.execute("What is the capital of France?")

        print(result.content)       # "The capital of France is Paris."
        print(result.success)       # True
        print(result.latency_ms)    # 1234.56

asyncio.run(main())
```

## Execution Options

Pass an `ExecutionOptions` object to control timeout, tool call limits, thinking mode, and more.

```python
import asyncio
from openclaw_sdk import OpenClawClient, ExecutionOptions

async def main():
    async with OpenClawClient.connect("ws://127.0.0.1:18789/gateway") as client:
        agent = client.get_agent("my-agent")

        options = ExecutionOptions(
            timeout_seconds=120,
            max_tool_calls=10,
            thinking=True,
        )
        result = await agent.execute("Analyze this dataset", options=options)

        # When thinking=True, the agent's reasoning is captured
        if result.thinking:
            print("Agent reasoning:", result.thinking)

        print(result.content)

asyncio.run(main())
```

## Idempotency

To prevent duplicate executions (e.g., on network retry), pass an `idempotency_key`. If the gateway has already processed a request with the same key, it returns the cached result.

```python
result = await agent.execute(
    "Generate a report for Q4",
    idempotency_key="report-q4-2025-run1",
)
```

!!! tip
    Use deterministic keys derived from your application logic (e.g., a task ID or request hash) rather than random UUIDs. This ensures retries actually deduplicate.

## Attachments

You can attach images to a query using the `Attachment` class. Attachments are base64-encoded and sent inline with the request.

```python
import asyncio
from openclaw_sdk import OpenClawClient, ExecutionOptions, Attachment

async def main():
    async with OpenClawClient.connect("ws://127.0.0.1:18789/gateway") as client:
        agent = client.get_agent("my-agent")

        attachment = Attachment.from_path("screenshot.png")

        result = await agent.execute(
            "Describe what you see in this image",
            options=ExecutionOptions(attachments=[attachment]),
        )
        print(result.content)

asyncio.run(main())
```

!!! warning
    Attachments are limited to **5 MB** per file and support **image formats only** (PNG, JPEG, GIF, WebP). Attempting to attach other file types or oversized files will raise a validation error.

## ExecutionResult Fields

Every call to `execute()` returns an `ExecutionResult` with these fields:

| Field | Type | Description |
|---|---|---|
| `content` | `str` | The agent's text response |
| `success` | `bool` | Whether execution completed without error |
| `latency_ms` | `float` | Wall-clock time in milliseconds |
| `token_usage` | `TokenUsage` | Input, output, and cache token counts |
| `thinking` | `str \| None` | Agent's chain-of-thought (when thinking mode is on) |
| `tool_calls` | `list[dict]` | Tools the agent invoked during execution |
| `files` | `list[dict]` | Files generated by the agent |
| `content_blocks` | `list[ContentBlock]` | Polymorphic content blocks (text or thinking) |
| `stop_reason` | `str \| None` | Why the agent stopped (e.g., `"end_turn"`, `"max_tokens"`) |

```python
result = await agent.execute("Summarize the document")

# Token usage breakdown
usage = result.token_usage
print(f"Input: {usage.input}, Output: {usage.output}, Total: {usage.total}")

# Check tool calls
for tc in result.tool_calls:
    print(f"Tool: {tc['name']}, Input: {tc['input']}")

# Content blocks for mixed content
for block in result.content_blocks:
    print(f"[{block.type}] {block.text[:80]}...")
```

## Batch Execution

Run multiple queries against the same agent concurrently with `batch()`. The `max_concurrency` parameter limits how many queries execute in parallel.

```python
import asyncio
from openclaw_sdk import OpenClawClient

async def main():
    async with OpenClawClient.connect("ws://127.0.0.1:18789/gateway") as client:
        agent = client.get_agent("my-agent")

        queries = [
            "Summarize chapter 1",
            "Summarize chapter 2",
            "Summarize chapter 3",
            "Summarize chapter 4",
        ]

        results = await agent.batch(queries, max_concurrency=2)

        for query, result in zip(queries, results):
            status = "OK" if result.success else "FAILED"
            print(f"[{status}] {query}: {result.content[:60]}...")

asyncio.run(main())
```

!!! tip
    Keep `max_concurrency` reasonable (2-5) to avoid overwhelming the gateway. The default is 5.

## Waiting for a Run

If you have a `run_id` from an earlier execution (e.g., from a webhook or fire-and-forget call), you can wait for it to complete.

```python
result = await agent.wait_for_run(run_id="run_abc123")
print(result.content)
```

## File Downloads

When an agent generates files during execution, you can download them afterward.

```python
result = await agent.execute("Generate a CSV report of sales data")

for file_info in result.files:
    file_data = await agent.get_file(file_info["path"])
    print(f"Downloaded: {file_info['path']} ({len(file_data)} bytes)")
```

## Memory and Status

Agents maintain conversational memory within a session. You can inspect and reset it.

```python
# Check agent operational status
status = await agent.get_status()
print(f"Agent status: {status}")

# Inspect memory usage for the current session
memory = await agent.get_memory_status()
print(f"Memory: {memory}")

# Clear session memory to start fresh
await agent.reset_memory()
```

!!! warning
    `reset_memory()` clears the entire conversation history for the current session. This cannot be undone.
